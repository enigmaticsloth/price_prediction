<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>Plotly Candlestick + Extremes Example</title>
  <!-- Plotly JS (CDN) -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #2d2d2d;
      color: #ccc;
    }
    #container {
      margin: 0 auto;
      padding: 10px;
      max-width: 1200px;
      width: 100%;
      box-sizing: border-box;
    }
    #controls {
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }
    #controls label {
      font-weight: bold;
      margin-right: 5px;
    }
    #controls select,
    #controls input {
      background-color: #444;
      color: #fff;
      border: 1px solid #666;
      padding: 6px 8px;
      font-size: 1rem;
    }
    #controls button {
      background-color: #666;
      color: #fff;
      border: 1px solid #888;
      padding: 6px 12px;
      cursor: pointer;
    }
    #chart {
      width: 100%;
      height: 600px;
      margin: 0 auto;
    }
    @media (max-width: 600px) {
      #chart {
        height: 400px;
      }
    }
    #confidence_div {
      margin: 10px 0;
      font-size: 1.2rem;
    }
  </style>
</head>
<body>

<div id="container">

  <!-- (A) 控制區塊：可選交易對、time_interval、extreme_window -->
  <div id="controls">
    <label for="symbol">Symbol:</label>
    <select id="symbol">
      <!-- 這裡先靜態列出四種交易對，若要擴充可自行增減 -->
      <option value="BTCUSDT" selected>BTCUSDT</option>
      <option value="ETHUSDT">ETHUSDT</option>
      <option value="SOLUSDT">SOLUSDT</option>
      <option value="XRPUSDT">XRPUSDT</option>
    </select>

    <label for="time_interval">Time Interval:</label>
    <select id="time_interval">
      <!-- 先靜態列出四種常見週期 -->
      <option value="1m">1 Minute</option>
      <option value="15m" selected>15 Minutes</option>
      <option value="1h">1 Hour</option>
      <option value="4h">4 Hours</option>
    </select>
    
    <label for="extreme_window">Extreme Window:</label>
    <input type="number" id="extreme_window" value="0" min="0" style="width:80px;" />
    
    <button id="btnQuery">查詢</button>
  </div>

  <!-- (B) 顯示「倒數第二個極值的可信度」 -->
  <div id="confidence_div"></div>

  <!-- (C) 圖表容器 -->
  <div id="chart"></div>

</div>

<script>
  // 1) 後端 API 路徑 (若已設定好 HTTPS，就用 https://rainmaker32.com/predict)
  //   若是 HTTP + 指定 port，例如: "http://rainmaker32.com:5000/predict"
  const PREDICT_URL = "https://rainmaker32.com/predict";

  // 2) 綁定按鈕
  document.addEventListener("DOMContentLoaded", () => {
    const btnQuery = document.getElementById("btnQuery");
    btnQuery.addEventListener("click", fetchPredictData);

    // 預設先自動跑一次查詢
    fetchPredictData();
  });

  // 3) 取得表單參數並發送 POST
  async function fetchPredictData() {
    // 讀取表單
    const symbol = document.getElementById("symbol").value;
    const time_interval = document.getElementById("time_interval").value;
    const extreme_window = parseInt(document.getElementById("extreme_window").value) || 0;

    // 組成 POST Body
    const reqBody = {
      symbol,
      time_interval,
      extreme_window
    };

    try {
      // 向後端發送 POST
      const res = await fetch(PREDICT_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(reqBody)
      });

      if(!res.ok) {
        // 若後端回傳錯誤
        const errData = await res.json();
        throw new Error(`HTTP ${res.status}, ${errData.error || res.statusText}`);
      }

      const data = await res.json();
      console.log("Predict Data =", data);

      // 顯示 second_last_extreme_confidence
      showSecondLastExtremeConfidence(data);

      // 把 extremes & ohlc 的 time 改成台灣時區 (+08:00) (若不需要可拿掉)
      convertToTaiwanTime(data);

      // 交給 Plotly 畫圖
      plotChart(data);

    } catch(err) {
      console.error("fetchPredictData Error:", err);
      alert("Failed to fetch data. " + err.message);
    }
  }

  // 4) 顯示倒數第二個極值的可信度
  function showSecondLastExtremeConfidence(data) {
    const val = data.second_last_extreme_confidence;
    const div = document.getElementById("confidence_div");
    if (val !== undefined && val !== null) {
      div.textContent = `Second last extreme confidence: ${val.toFixed(4)}`;
    } else {
      div.textContent = "No second last extreme confidence available.";
    }
  }

  // 5) 將 UTC 時間轉為台灣時間 "YYYY-MM-DDTHH:mm:ss+08:00"
  function toTaiwanTime(isoString) {
    const utcDate = new Date(isoString);
    // 加上 8 小時
    utcDate.setHours(utcDate.getHours() + 8);

    const yyyy = utcDate.getFullYear();
    const MM = String(utcDate.getMonth() + 1).padStart(2, '0');
    const dd = String(utcDate.getDate()).padStart(2, '0');
    const hh = String(utcDate.getHours()).padStart(2, '0');
    const mm = String(utcDate.getMinutes()).padStart(2, '0');
    const ss = String(utcDate.getSeconds()).padStart(2, '0');

    return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}+08:00`;
  }

  function convertToTaiwanTime(data) {
    // extremes
    if (data.extremes && Array.isArray(data.extremes)) {
      data.extremes.forEach(e => {
        e.time = toTaiwanTime(e.time);
      });
    }
    // ohlc
    if (data.ohlc && Array.isArray(data.ohlc)) {
      data.ohlc.forEach(o => {
        o.time = toTaiwanTime(o.time);
      });
    }
  }

  // 6) Plotly 畫圖
  function plotChart(data) {
    const extremes = data.extremes || [];
    const ohlc = data.ohlc || [];

    // 確保時間排序
    ohlc.sort((a,b) => new Date(a.time) - new Date(b.time));
    extremes.sort((a,b) => new Date(a.time) - new Date(b.time));

    // K線
    const candlestickTrace = {
      x: ohlc.map(x => x.time),
      open: ohlc.map(x => x.open),
      high: ohlc.map(x => x.high),
      low: ohlc.map(x => x.low),
      close: ohlc.map(x => x.close),
      type: 'candlestick',
      name: 'Candlestick',
      yaxis: 'y1'
    };

    // Volume (柱狀)
    const volumeColors = ohlc.map(d =>
      (d.close > d.open) ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'
    );
    const volumeTrace = {
      x: ohlc.map(d => d.time),
      y: ohlc.map(d => d.volume),
      type: 'bar',
      name: 'Volume',
      marker: { color: volumeColors },
      yaxis: 'y2'
    };

    // Extremes (High=紅三角向上, Low=藍三角向下)
    const extremesTrace = {
      x: extremes.map(e => e.time),
      y: extremes.map(e =>
        e.label === 1
          ? e.close * 1.02 // 高點略上移
          : e.close * 0.98 // 低點略下移
      ),
      mode: 'markers',
      name: 'Extremes',
      text: extremes.map(e => (e.label === 1 ? 'High' : 'Low')),
      hovertemplate: 'Time=%{x}<br>Price=%{y}<extra>%{text}</extra>',
      marker: {
        color: extremes.map(e => (e.label === 1 ? 'red' : 'blue')),
        size: 12,
        symbol: extremes.map(e => (e.label === 1 ? 'triangle-up' : 'triangle-down'))
      },
      yaxis: 'y1'
    };

    // 只顯示最後 50~100 根 K (可自行調整)
    let xMin, xMax;
    if (ohlc.length > 50) {
      const last50 = ohlc.slice(-50);
      xMin = last50[0].time;
      xMax = last50[last50.length-1].time;
    } else if (ohlc.length > 0) {
      xMin = ohlc[0].time;
      xMax = ohlc[ohlc.length-1].time;
    } else {
      xMin = new Date().toISOString();
      xMax = new Date().toISOString();
    }

    // Layout
    const layout = {
      paper_bgcolor: "#2d2d2d",
      plot_bgcolor: "#2d2d2d",
      font: { color: "#ccc" },
      xaxis: {
        type: 'date',
        range: [xMin, xMax],
        domain: [0, 1],
        anchor: 'y1',
        gridcolor: '#444',
        title: 'Time (UTC+8)'
      },
      yaxis: {
        title: 'Price',
        domain: [0.3, 1],
        anchor: 'x',
        side: 'left',
        gridcolor: '#444'
      },
      yaxis2: {
        title: 'Volume',
        domain: [0, 0.25],
        anchor: 'x',
        side: 'left',
        gridcolor: '#444'
      },
      dragmode: 'pan',
      legend: {
        orientation: 'h',
        x: 0.1,
        y: 1.1
      },
      margin: { t: 50 }
    };

    // Trace 組合
    const dataTraces = [candlestickTrace, volumeTrace, extremesTrace];

    Plotly.newPlot('chart', dataTraces, layout, {responsive: true});
  }
</script>

</body>
</html>