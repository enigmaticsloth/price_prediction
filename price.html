<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>Plotly Candlestick + Extremes + Volume (Auto Refresh + Responsive Layout)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* 1. 全域設定：自適應佈局、深色背景 */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #2d2d2d;
      color: #ccc;
    }

    /* 2. 容器寬度自適應 + 最大寬度 */
    #container {
      margin: 0 auto;
      padding: 10px;
      max-width: 1200px;
      width: 100%;
      box-sizing: border-box;
    }

    /* 3. 上方控制介面 */
    #controls {
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }

    #controls label {
      font-size: 1rem;
    }

    #controls select,
    #controls input {
      background-color: #444;
      color: #fff;
      border: 1px solid #666;
      padding: 6px 8px;
      font-size: 1.2rem;
    }

    #update_btn {
      background-color: #555;
      color: #fff;
      border: 1px solid #666;
      cursor: pointer;
      font-size: 1rem;
      padding: 6px 12px;
    }
    #update_btn:hover {
      background-color: #666;
    }

    /* 4. 圖表區域：寬度隨容器自適應 */
    #chart {
      width: 100%;
      height: 600px; 
      margin: 0 auto;
    }

    @media (max-width: 600px) {
      #chart {
        height: 400px;
      }
    }
  </style>
</head>
<body>

<div id="container">
  <!-- (A) 上方控制欄位 -->
  <div id="controls">
    <label for="time_interval">Time Interval:</label>
    <select id="time_interval">
      <option value="1m">1 Minute</option>
      <option value="15m" selected>15 Minutes</option>
      <option value="1h">1 Hour</option>
    </select>
    
    <label for="extreme_window">Extreme Window:</label>
    <input type="number" id="extreme_window" value="0" min="0" />
  </div>

  <!-- (B) 這裡顯示「倒數第二個 extreme 的可信度」 (已改英文) -->
  <div id="confidence_div" style="margin: 10px 0; font-size: 1.2rem;">
    <!-- 透過 JS 動態填入 -->
  </div>
  
  <!-- (C) 主圖表區 -->
  <div id="chart"></div>
</div>

<script>
  // ===== (1) 將後端回傳的 UTC 時間字串轉換為台灣時區 (UTC+8) =====
  function toTaiwanTime(isoString) {
    // 1) 先取得原 UTC 時間
    const utcDate = new Date(isoString);

    // 2) 加上 8 小時(以毫秒計)
    const taipeiOffsetMS = 8 * 60 * 60 * 1000;
    const localTime = new Date(utcDate.getTime() + taipeiOffsetMS);

    // 3) 回傳標準 ISO 格式 (去除最後的 'Z')
    //    e.g. "2023-01-31T08:00:00"
    return localTime.toISOString().replace('Z', '');
  }

  // ===== (2) 區分 cluster 用的顏色 =====
  const clusterColors = [
    '#66c2a5', // cluster=0
    '#fdae61', // cluster=1
    '#3288bd', // cluster=2
    '#fee08b', // cluster=3
    '#d53e4f', // cluster=4
    '#5e4fa2'  // cluster=5
  ];

  let symbol = "BTCUSDT";
  let time_interval = "15m";
  let extreme_window = 0;

  // ===== (3) 向後端抓資料 =====
  async function fetchPredictData() {
    // 依照實際後端地址修改
    const url = "https://rainmaker32.com/predict"; 

    const postBody = {
      symbol: symbol,
      time_interval: time_interval,
      extreme_window: extreme_window
    };

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(postBody)
      });
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(`HTTP error! status: ${res.status}, message: ${errorData.error}`);
      }
      const data = await res.json();
      console.log("Data from backend =", data);

      // (A) 顯示倒數第二個極值的可信度 (已改英文)
      showSecondLastExtremeConfidence(data);

      // (B) 時間轉成台灣時區
      convertToTaiwanTime(data);

      // (C) 繪圖
      plotChart(data);

    } catch (err) {
      console.error("fetchPredictData() error:", err);
      alert("Failed to fetch data. Please check console logs!");
    }
  }

  // ===== (4) 顯示「倒數第二個 extreme 的可信度」 =====
  function showSecondLastExtremeConfidence(data) {
    const val = data.second_last_extreme_confidence;
    const div = document.getElementById("confidence_div");
    if (val !== undefined && val !== null) {
      // 英文顯示
      div.textContent = `Second last extreme confidence: ${val.toFixed(4)}`;
    } else {
      div.textContent = "Unable to get second last extreme confidence.";
    }
  }

  // ===== (5) 將 extremes / ohlc 的 time 欄位改為台灣時區 =====
  function convertToTaiwanTime(data) {
    const { extremes, ohlc } = data;
    if (extremes && extremes.length > 0) {
      extremes.forEach(e => {
        e.time = toTaiwanTime(e.time);
      });
    }
    if (ohlc && ohlc.length > 0) {
      ohlc.forEach(o => {
        o.time = toTaiwanTime(o.time);
      });
    }
  }

  // ===== (6) 繪製圖表 =====
  function plotChart(data) {
    const extremes = data.extremes || [];
    const ohlc = data.ohlc || [];

    // 排序以免亂序
    extremes.sort((a, b) => new Date(a.time) - new Date(b.time));
    ohlc.sort((a, b) => new Date(a.time) - new Date(b.time));

    // 建立 K線 traces (依 cluster 分組顯示)
    const uniqueClusters = [...new Set(ohlc.map(d => d.cluster))].sort((a, b) => a - b);
    const candlestickTraces = uniqueClusters.map(c => {
      const subset = ohlc.filter(x => x.cluster === c);
      return {
        x: subset.map(d => d.time),
        open: subset.map(d => d.open),
        high: subset.map(d => d.high),
        low: subset.map(d => d.low),
        close: subset.map(d => d.close),
        type: 'candlestick',
        name: `Cluster ${c}`,
        increasing: { line: { color: clusterColors[c] || 'gray' } },
        decreasing: { line: { color: clusterColors[c] || 'gray' } },
        showlegend: c === 0  // 只在第一組顯示 legend
      };
    });

    // extremes scatter (使用不同顏色與圖示)
    const extremesTrace = {
      x: extremes.map(e => e.time),
      y: extremes.map(e => e.label === 1 ? e.close * 1.02 : e.close * 0.98),
      mode: 'markers',
      name: 'Extremes',
      text: extremes.map(e => (e.label === 1 ? 'High' : 'Low')),
      hovertemplate: 'Time=%{x}<br>Price=%{y}<extra>%{text}</extra>',
      marker: {
        color: extremes.map(e => (e.label === 1 ? 'red' : 'blue')),
        size: 12,
        symbol: extremes.map(e => (e.label === 1 ? 'triangle-up' : 'triangle-down'))
      },
      type: 'scatter',
      yaxis: 'y1'
    };

    // Volume bar (紅綠判斷)
    const volumeColors = ohlc.map(d =>
      (d.close > d.open) ? 'rgba(0,255,0,0.5)' : 'rgba(255,0,0,0.5)'
    );
    const volumeTrace = {
      x: ohlc.map(d => d.time),
      y: ohlc.map(d => d.volume),
      type: 'bar',
      name: 'Volume',
      marker: { color: volumeColors },
      yaxis: 'y2'
    };

    // 整合
    const allTraces = [...candlestickTraces, extremesTrace, volumeTrace];

    // 若 K 棒很多，預設只看最近 50 根
    let xMin, xMax;
    if (ohlc.length > 50) {
      const last50 = ohlc.slice(-50);
      xMin = last50[0].time;
      xMax = last50[last50.length - 1].time;
    } else if (ohlc.length > 0) {
      xMin = ohlc[0].time;
      xMax = ohlc[ohlc.length - 1].time;
    } else {
      // 若無資料
      xMin = new Date().toISOString();
      xMax = new Date().toISOString();
    }

    // Plotly 版面
    const layout = {
      paper_bgcolor: "#2d2d2d",
      plot_bgcolor: "#2d2d2d",
      font: { color: "#ccc" },
      xaxis: {
        title: 'Time (Taiwan Time)',
        type: 'date',
        range: [xMin, xMax],
        domain: [0, 1],
        anchor: 'y1',
        gridcolor: '#444'
      },
      yaxis: {
        title: 'Price',
        domain: [0.3, 1],
        anchor: 'x',
        side: 'left',
        gridcolor: '#444'
      },
      yaxis2: {
        title: 'Volume',
        domain: [0, 0.25],
        anchor: 'x',
        side: 'left',
        gridcolor: '#444'
      },
      dragmode: 'pan',
      legend: {
        orientation: 'h',
        x: 0.1,
        y: 1.15
      },
      margin: { t: 50 }
    };

    Plotly.newPlot('chart', allTraces, layout, { responsive: true });
  }

  // ===== (7) 綁定事件 & 自動刷新 =====
  document.getElementById('time_interval').addEventListener('change', () => {
    time_interval = document.getElementById('time_interval').value;
    fetchPredictData();
  });

  document.getElementById('extreme_window').addEventListener('change', () => {
    extreme_window = parseInt(document.getElementById('extreme_window').value) || 0;
    fetchPredictData();
  });

  // DOM 載入後預設先抓資料, 並每10秒自動更新
  document.addEventListener('DOMContentLoaded', () => {
    fetchPredictData();
    setInterval(() => {
      fetchPredictData();
    }, 10000);
  });
</script>
</body>
</html>