<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>Plotly Candlestick + Extremes + Volume (Auto-refresh every 10s, Pan mode)</title>
  <!-- 載入 Plotly JS CDN -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #controls {
      margin: 20px;
    }
    #controls label {
      margin-right: 10px;
    }
    #controls select, #controls input {
      margin-right: 20px;
      padding: 5px;
    }
    #chart {
      width: 90%;
      height: 800px; /* 調整高度以容納兩個子圖 */
      margin: 0 auto;
    }
  </style>
</head>
<body>
  
  <div id="controls">
    <label for="time_interval">Time Interval:</label>
    <select id="time_interval">
      <option value="1m">1 Minute</option>
      <option value="15m" selected>15 Minutes</option>
      <option value="1h">1 Hour</option>
    </select>
    
    <label for="extreme_window">Extreme Window:</label>
    <input type="number" id="extreme_window" value="0" min="0" />
    
    <button id="update_btn">Update Chart</button>
  </div>
  
  <div id="chart"></div>
  
  <script>
  // (A) Cluster color mapping
  const clusterColors = [
    '#66c2a5', // cluster=0
    '#fdae61', // cluster=1
    '#3288bd', // cluster=2
    '#fee08b', // cluster=3
    '#d53e4f', // cluster=4
    '#5e4fa2'  // cluster=5
  ];

  // (B) Global Variables for Parameters
  let symbol = "BTCUSDT";
  let time_interval = "15m"; // Default selected in dropdown
  let extreme_window = 0;

  // (C) Fetch data from Flask API
  async function fetchPredictData() {
    const url = "http://35.201.180.30:5000/predict";

    const postBody = {
      symbol: symbol,
      time_interval: time_interval,
      extreme_window: extreme_window
    };

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(postBody)
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(`HTTP error! status: ${res.status}, message: ${errorData.error}`);
      }

      const data = await res.json();
      console.log("Data from backend =", data);
      plotChart(data);

    } catch (err) {
      console.error("Error in fetchPredictData():", err);
      alert("無法取得資料，請檢查控制台以獲取詳細錯誤訊息！");
    }
  }

  // (D) Plot the candlestick + extremes + Volume
  function plotChart(data) {
    let extremes = data.extremes || [];
    let ohlc = data.ohlc || [];

    // 1. sort them by time
    extremes.sort((a, b) => new Date(a.time) - new Date(b.time));
    ohlc.sort((a, b) => new Date(a.time) - new Date(b.time));

    // 2. build multiple candlestick traces by cluster
    const uniqueClusters = [...new Set(ohlc.map(d => d.cluster))].sort((a, b) => a - b);

    const candlestickTraces = uniqueClusters.map(c => {
      const subset = ohlc.filter(x => x.cluster === c);
      return {
        x: subset.map(d => d.time),
        open: subset.map(d => d.open),
        high: subset.map(d => d.high),
        low: subset.map(d => d.low),
        close: subset.map(d => d.close),
        type: 'candlestick',
        name: `Cluster ${c}`,
        increasing: { line: { color: clusterColors[c] || 'gray' } },
        decreasing: { line: { color: clusterColors[c] || 'gray' } },
        showlegend: c === 0 // 只顯示一次圖例
      };
    });

    // 3. extremes scatter with enlarged arrows
    const extremesTrace = {
      x: extremes.map(e => e.time),
      y: extremes.map(e => {
        // offset so arrow doesn't overlap candle
        if (e.label === 1) {
          // high => offset above
          return e.close * 1.02; 
        } else {
          // low => offset below
          return e.close * 0.98; 
        }
      }),
      mode: 'markers',
      name: 'Extremes',
      text: extremes.map(e => e.label === 1 ? 'High' : 'Low'),
      hovertemplate: 'Time=%{x}<br>Price=%{y}<extra>%{text}</extra>',
      marker: {
        // high => red, low => blue
        color: extremes.map(e => e.label === 1 ? 'red' : 'blue'),
        size: 12, // 增大標記大小
        symbol: extremes.map(e => (e.label === 1 ? 'triangle-up' : 'triangle-down'))
      },
      type: 'scatter',
      yaxis: 'y1'
    };

    // 4. Volume trace
    const volumeTrace = {
      x: ohlc.map(d => d.time),
      y: ohlc.map(d => d.volume),
      type: 'bar',
      name: 'Volume',
      marker: {
        color: 'rgba(100, 100, 100, 0.5)'
      },
      yaxis: 'y2'
    };

    // 5. Combine all traces
    const allTraces = [...candlestickTraces, extremesTrace, volumeTrace];

    // 6. Determine default x-range => last 50 bars
    let xMin, xMax;
    if (ohlc.length > 0) {
      const last50 = ohlc.slice(-50);
      xMin = last50[0].time;
      xMax = last50[last50.length - 1].time;
    } else {
      // fallback if no data
      xMin = new Date().toISOString();
      xMax = new Date().toISOString();
    }

    // 7. Layout with subplots for candlestick and volume
    const layout = {
      title: '', // 移除標題
      xaxis: {
        title: 'Time',
        type: 'date',
        range: [xMin, xMax],
        domain: [0, 1],
        anchor: 'y1'
      },
      yaxis: {
        title: 'Price',
        domain: [0.3, 1],
        anchor: 'x',
        side: 'left'
      },
      yaxis2: {
        title: 'Volume',
        domain: [0, 0.25],
        anchor: 'x',
        side: 'left'
      },
      dragmode: 'pan', // default to pan mode
      legend: {
        orientation: "h",
        x: 0.1,
        y: 1.15
      },
      margin: { t: 50 } // 增加上方邊距以避免圖例遮擋
    };

    // 8. Render with subplots
    Plotly.newPlot('chart', allTraces, layout, {responsive: true});
  }

  // (E) Handle Update Button Click
  document.getElementById('update_btn').addEventListener('click', () => {
    // Get user-selected time_interval and extreme_window
    time_interval = document.getElementById('time_interval').value;
    extreme_window = parseInt(document.getElementById('extreme_window').value) || 0;

    // Fetch and update chart
    fetchPredictData();
  });

  // (F) Initial Fetch & Auto-update every 10 seconds
  document.addEventListener("DOMContentLoaded", () => {
    fetchPredictData();
    // Auto update every 10 sec
    setInterval(() => {
      fetchPredictData();
    }, 10000);
  });
  </script>
</body>
</html>